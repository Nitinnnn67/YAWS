<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Stickman</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            height: 100vh;
        }
        canvas {
            display: block;
            position: absolute;
            z-index: 1000;
            pointer-events: none;
        }
        #stickman {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!--
    An autonomous stickman that moves (by walking, running, jumping, like a human, randomly) around the screen.
    it should obey the laws of physics (gravity, friction, etc.)
    it should be very small in size (in terms of pixels), like it should not bother the reader on the page.
    it should be able to detect the edges of the screen and turn around.
    it should easter egg. hidden witin the website soemwhere, and should be used like framework such that it can be easily copied into any other website.
    code as complex as you can but it should work definitely like that.
    use canvas for drawing the stickman, but keep my requirments in mind, and for now we are testing so just make some floor here, like a horizontal line.
    and some other slops with lines, so that stickman can walk on it. its movement should be humoniod and random. like a human.
    should feel like a living being on the screen. dont use any external lib. just pure js, css and html.
    -->
    <div id="stickman">
        <canvas id="stickmanCanvas"></canvas>
    </div>
    <script>
        // StickMan Easter Egg - Self-Executing Anonymous Function
        (function() {
            // Easter egg activation - hidden by default, reveal with 'stickman' in console or Konami code
            let isActive = false;
            const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 
                               'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
            let konamiIndex = 0;
            
            // Initialize canvas
            const canvas = document.getElementById('stickmanCanvas');
            const ctx = canvas.getContext('2d');
            
            // Resize canvas to match window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Hide stickman by default
            canvas.style.display = 'none';
            
            // Physics constants - adjusted for better behavior
            const GRAVITY = 0.4;
            const FRICTION = 0.85;
            const GROUND_FRICTION = 0.8;
            const JUMP_FORCE = 10;
            const WALK_SPEED = 2;
            const RUN_SPEED = 4;
            
            // Terrain generation
            class Terrain {
                constructor() {
                    this.platforms = [];
                    this.generateTerrain();
                }
                
                generateTerrain() {
                    // Main ground level
                    this.platforms.push({
                        x1: 0,
                        y1: canvas.height - 50,
                        x2: canvas.width,
                        y2: canvas.height - 50,
                        isFlat: true
                    });
                    
                    // Add some slopes and platforms
                    this.platforms.push({
                        x1: 200,
                        y1: canvas.height - 150,
                        x2: 450,
                        y2: canvas.height - 100,
                        isFlat: false
                    });
                    
                    this.platforms.push({
                        x1: 600,
                        y1: canvas.height - 200,
                        x2: 900,
                        y2: canvas.height - 200,
                        isFlat: true
                    });
                    
                    this.platforms.push({
                        x1: 1000,
                        y1: canvas.height - 250,
                        x2: 1200,
                        y2: canvas.height - 150,
                        isFlat: false
                    });
                }
                
                // Regenerate terrain when window is resized
                updateTerrain() {
                    this.platforms = [];
                    this.generateTerrain();
                }
                
                draw() {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    for (let platform of this.platforms) {
                        ctx.beginPath();
                        ctx.moveTo(platform.x1, platform.y1);
                        ctx.lineTo(platform.x2, platform.y2);
                        ctx.stroke();
                    }
                }
                
                checkCollision(x, y, prevY, radius) {
                    let collision = { collision: false };
                    let closestDistance = Infinity;
                    
                    for (let platform of this.platforms) {
                        // Calculate the platform's slope
                        const slope = (platform.y2 - platform.y1) / (platform.x2 - platform.x1);
                        const yIntercept = platform.y1 - slope * platform.x1;
                        
                        // Calculate the expected y-position on this line at our x-position
                        const expectedY = slope * x + yIntercept;
                        
                        // Check if we're within the x-range of the platform
                        if (x >= platform.x1 && x <= platform.x2) {
                            // Check if we're falling onto the platform
                            if (y >= expectedY - radius && prevY < expectedY - radius) {
                                // If this collision is closer than previously found ones
                                const distance = y - (expectedY - radius);
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    collision = {
                                        collision: true,
                                        y: expectedY - radius,
                                        slope: slope,
                                        isFlat: platform.isFlat
                                    };
                                }
                            }
                        }
                    }
                    
                    return collision;
                }
            }
            
            // Stickman class
            class Stickman {
                constructor() {
                    this.size = 15; // Small size as requested
                    this.x = 100;
                    this.y = 100;
                    this.prevY = 100;
                    this.vx = 0;
                    this.vy = 0;
                    this.onGround = false;
                    this.currentPlatformSlope = 0;
                    this.facingRight = true;
                    this.legAngle = 0;
                    this.armAngle = 0;
                    this.walkCycle = 0;
                    this.state = 'idle'; // idle, walking, running, jumping
                    this.idleTime = 0;
                    this.thinkTime = 0;
                    this.decisionTimeout = Math.random() * 100 + 50;
                    this.stablePlatform = false;
                }
                
                update(terrain) {
                    // Store previous position for collision detection
                    this.prevY = this.y;
                    
                    // Apply physics - gravity always acts
                    this.vy += GRAVITY;
                    
                    // Apply platform slope effect to x velocity when on ground
                    if (this.onGround && !this.stablePlatform) {
                        this.vx += this.currentPlatformSlope * 0.05;
                    }
                    
                    // Apply velocities to position
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // Check collision with edges
                    if (this.x < this.size) {
                        this.x = this.size;
                        this.vx = Math.abs(this.vx) * 0.5; // Bounce and move right
                        this.facingRight = true;
                    }
                    
                    if (this.x > canvas.width - this.size) {
                        this.x = canvas.width - this.size;
                        this.vx = -Math.abs(this.vx) * 0.5; // Bounce and move left
                        this.facingRight = false;
                    }
                    
                    // Reset onGround status before collision check
                    this.onGround = false;
                    
                    // Check collision with terrain - using feet position (bottom of stickman)
                    const footY = this.y + this.size;
                    const prevFootY = this.prevY + this.size;
                    const collision = terrain.checkCollision(this.x, footY, prevFootY, 0);
                    
                    if (collision.collision) {
                        this.y = collision.y - this.size; // Position exactly on the platform
                        this.vy = 0;
                        this.onGround = true;
                        this.currentPlatformSlope = collision.slope;
                        this.stablePlatform = collision.isFlat;
                    }
                    
                    // Apply friction
                    if (this.onGround) {
                        this.vx *= GROUND_FRICTION;
                    } else {
                        this.vx *= FRICTION;
                    }
                    
                    // Stop if velocity is very small
                    if (Math.abs(this.vx) < 0.1) {
                        this.vx = 0;
                    }
                    
                    // Animation cycles
                    if (Math.abs(this.vx) > 0.5) {
                        this.walkCycle += Math.abs(this.vx) / 10;
                        this.legAngle = Math.sin(this.walkCycle) * 0.5;
                        this.armAngle = Math.sin(this.walkCycle + Math.PI) * 0.3;
                    } else {
                        this.legAngle = 0;
                        this.armAngle = 0;
                    }
                    
                    // State determination
                    if (!this.onGround) {
                        this.state = 'jumping';
                    } else if (Math.abs(this.vx) > 3) {
                        this.state = 'running';
                    } else if (Math.abs(this.vx) > 0.5) {
                        this.state = 'walking';
                    } else {
                        this.state = 'idle';
                    }
                    
                    // AI decision making
                    this.thinkTime++;
                    if (this.state === 'idle') {
                        this.idleTime++;
                    } else {
                        this.idleTime = 0;
                    }
                    
                    if (this.thinkTime > this.decisionTimeout) {
                        this.makeDecision();
                        this.thinkTime = 0;
                        this.decisionTimeout = Math.random() * 100 + 30;
                    }
                }
                
                makeDecision() {
                    const rand = Math.random();
                    
                    // More likely to move if idle for a while
                    if (this.idleTime > 50 || rand < 0.7) {
                        // Decide direction
                        if (Math.random() > 0.5) {
                            this.facingRight = !this.facingRight;
                        }
                        
                        // Decide movement type
                        const moveType = Math.random();
                        if (moveType < 0.2 && this.onGround) {
                            // Jump
                            this.jump();
                        } else if (moveType < 0.6) {
                            // Run
                            this.run();
                        } else {
                            // Walk
                            this.walk();
                        }
                    } else {
                        // Stop and idle
                        this.vx *= 0.5;
                    }
                }
                
                walk() {
                    const direction = this.facingRight ? 1 : -1;
                    this.vx = direction * WALK_SPEED;
                }
                
                run() {
                    const direction = this.facingRight ? 1 : -1;
                    this.vx = direction * RUN_SPEED;
                }
                
                jump() {
                    if (this.onGround) {
                        this.vy = -JUMP_FORCE;
                        this.onGround = false;
                    }
                }
                
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Flip if facing left
                    if (!this.facingRight) {
                        ctx.scale(-1, 1);
                    }
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.9, this.size * 0.4, 0, Math.PI * 2);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Body
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size * 0.5);
                    ctx.lineTo(0, this.size * 0.3);
                    ctx.stroke();
                    
                    // Arms with animation
                    ctx.beginPath();
                    // Left arm
                    ctx.moveTo(0, -this.size * 0.3);
                    ctx.lineTo(this.size * 0.6 * Math.cos(this.armAngle - Math.PI/4), 
                              -this.size * 0.3 + this.size * 0.6 * Math.sin(this.armAngle - Math.PI/4));
                    
                    // Right arm
                    ctx.moveTo(0, -this.size * 0.3);
                    ctx.lineTo(this.size * 0.6 * Math.cos(this.armAngle + Math.PI/4), 
                              -this.size * 0.3 + this.size * 0.6 * Math.sin(this.armAngle + Math.PI/4));
                    ctx.stroke();
                    
                    // Legs with animation
                    ctx.beginPath();
                    // Left leg
                    ctx.moveTo(0, this.size * 0.3);
                    ctx.lineTo(this.size * 0.6 * Math.cos(this.legAngle - Math.PI/4), 
                              this.size * 0.3 + this.size * 0.6 * Math.sin(this.legAngle - Math.PI/4));
                    
                    // Right leg
                    ctx.moveTo(0, this.size * 0.3);
                    ctx.lineTo(this.size * 0.6 * Math.cos(this.legAngle + Math.PI/4), 
                              this.size * 0.3 + this.size * 0.6 * Math.sin(this.legAngle + Math.PI/4));
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
            
            // Main game objects
            const terrain = new Terrain();
            const stickman = new Stickman();
            
            // Resize handler - update terrain when window resizes
            window.addEventListener('resize', function() {
                terrain.updateTerrain();
            });
            
            // Game loop
            function gameLoop() {
                if (!isActive) {
                    requestAnimationFrame(gameLoop);
                    return;
                }
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw terrain
                terrain.draw();
                
                // Update and draw stickman
                stickman.update(terrain);
                stickman.draw();
                
                requestAnimationFrame(gameLoop);
            }
            
            // Start the game loop
            gameLoop();
            
            // Initial stickman placement - start on the ground
            function placeStickmanOnGround() {
                stickman.x = Math.random() * canvas.width * 0.8 + canvas.width * 0.1; // 10-90% of width
                stickman.y = 0;
                stickman.vy = 0;
                
                // Let the stickman fall until he hits the ground
                let initialFall = setInterval(function() {
                    stickman.prevY = stickman.y;
                    stickman.y += 5;
                    
                    const footY = stickman.y + stickman.size;
                    const prevFootY = stickman.prevY + stickman.size;
                    const collision = terrain.checkCollision(stickman.x, footY, prevFootY, 0);
                    
                    if (collision.collision) {
                        stickman.y = collision.y - stickman.size;
                        stickman.onGround = true;
                        stickman.currentPlatformSlope = collision.slope;
                        stickman.stablePlatform = collision.isFlat;
                        clearInterval(initialFall);
                    }
                    
                    // Safety check to prevent infinite falling
                    if (stickman.y > canvas.height) {
                        stickman.y = canvas.height - 100;
                        clearInterval(initialFall);
                    }
                }, 10);
            }
            
            // Konami code listener
            document.addEventListener('keydown', function(e) {
                if (e.key === konamiCode[konamiIndex]) {
                    konamiIndex++;
                    if (konamiIndex === konamiCode.length) {
                        activateStickman();
                        konamiIndex = 0;
                    }
                } else {
                    konamiIndex = 0;
                }
            });
            
            // Console command listener
            const originalConsoleLog = console.log;
            console.log = function() {
                const args = Array.from(arguments);
                if (args.length > 0 && typeof args[0] === 'string' && args[0].toLowerCase() === 'stickman') {
                    activateStickman();
                }
                return originalConsoleLog.apply(console, arguments);
            };
            
            function activateStickman() {
                if (!isActive) {
                    isActive = true;
                    canvas.style.display = 'block';
                    placeStickmanOnGround(); // Place stickman on a platform
                    console.log("%cStickman activated!", "color: green; font-weight: bold");
                } else {
                    isActive = false;
                    canvas.style.display = 'none';
                    console.log("%cStickman deactivated!", "color: red; font-weight: bold");
                }
            }
            
            // Easter egg instruction (only visible in source)
            console.log("%cThere's a hidden easter egg in this page! Hint: Konami code or type 'stickman' in console", "color: #999; font-style: italic;");
            
            // Public API for external use (as a framework)
            window.StickmanAPI = {
                activate: activateStickman,
                isActive: function() { return isActive; }
            };
        })();
    </script>
</body>
</html>
